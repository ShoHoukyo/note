"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[6363],{55785:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var o=t(24246),s=t(71670);const i={},r=void 0,a={id:"my/public/software/JavaScript/zod",title:"zod",description:"vs. Typescript",source:"@site/docs/my/public/software/JavaScript/zod.md",sourceDirName:"my/public/software/JavaScript",slug:"/my/public/software/JavaScript/zod",permalink:"/note/docs/my/public/software/JavaScript/zod",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"mySidebar",previous:{title:"vite",permalink:"/note/docs/my/public/software/JavaScript/vite"},next:{title:"profile",permalink:"/note/docs/my/public/software/OS/Linux/Android/profile"}},c={},l=[{value:"vs. Typescript",id:"vs-typescript",level:3},{value:"condition",id:"condition",level:3},{value:"operation on fields",id:"operation-on-fields",level:3},{value:"convert zod type automatically",id:"convert-zod-type-automatically",level:3}];function d(n){const e={a:"a",code:"code",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h3,{id:"vs-typescript",children:"vs. Typescript"}),"\n",(0,o.jsx)(e.p,{children:"pros:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["has ",(0,o.jsx)(e.code,{children:"default()"})]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"condition",children:"condition"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.a,{href:"https://github.com/colinhacks/zod/issues/61",children:"Require 1 of 2 fields, good general discussion on conditional validation  zod \xb7 GitHub"}),"\n2023-08-31 no good neat solution"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"// https://stackoverflow.com/questions/73281501/at-least-one-minimum-one-field-in-zod-schema-validation\n\n// p2 need more testing\nconst atLeast1Defined = (obj: Record<string | number | symbol, unknown>) =>\n  Object.values(obj).some(v => v !== undefined);\n  \n"})}),"\n",(0,o.jsx)(e.h3,{id:"operation-on-fields",children:"operation on fields"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.a,{href:"https://github.com/colinhacks/zod/discussions/2050",children:"https://github.com/colinhacks/zod/discussions/2050"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"function makeOptionalPropsNullable<Schema extends z.AnyZodObject> ( schema: Schema ) {\n    const entries = Object.entries( schema.shape ) as\n        [ keyof Schema[ 'shape' ], z.ZodTypeAny ][]\n    const newProps = entries.reduce( ( acc, [ key, value ] ) => {\n        acc[ key ] = value instanceof z.ZodOptional\n            ? value.unwrap().nullable()\n            : value\n        return acc\n    }, {} as {\n        [ key in keyof Schema[ 'shape' ] ]: Schema[ 'shape' ][ key ] extends z.ZodOptional<infer T>\n        ? z.ZodNullable<T>\n        : Schema[ 'shape' ][ key ]\n    } )\n    return z.object( newProps )\n}\n\nconst Person = z.object( {\n    firstName: z.string(),\n    lastName: z.string(),\n    email: z.string().optional(),\n    address: z.string().nullable(),\n} )\n\nconst serverPerson = makeOptionalPropsNullable( Person )\ntype ServerPerson = z.infer<typeof serverPerson>\n// type ServerPerson = {\n//     firstName: string\n//     lastName: string\n//     email: string | null\n//     address: string | null\n// }\n"})}),"\n",(0,o.jsx)(e.h3,{id:"convert-zod-type-automatically",children:"convert zod type automatically"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"// I have this zod object\nz.object({nickname: z.string().min(1),\n    gender: z.union([\n      z.literal('male'),\n      z.literal('female'),\n    ])})\n    \n// to DynamoDB model (note the 'S')\n// I want this zod object (but not manually) somehow automatically\nz.object({nickname: z.object({ S: z.string().min(1)}),\n    gender: z.object({ S: z.union([\n      z.literal('male'),\n      z.literal('female'),\n    ])})})\n"})}),"\n",(0,o.jsx)(e.p,{children:"Solution 1 (reverse conversion)"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"// don't do this, needs testing and deep understanding of zod\n\nconst nickname = z.string().min(1);\ntype nickname = z.infer<typeof nickname>;\n\nconst DdbModel = z.object({\n  S: z.object({\n    nickname,\n  }),\n  N: z.object({\n    somenumber: z.string(),\n  }),\n});\ntype DdbModel = z.infer<typeof DdbModel>;\n\nconst Model = DdbModel.transform((val) => {\n  if (val.S) {\n    return val.S;\n  }\n\n  return val.N;  // wrong, it's number\n});\ntype Model = z.infer<typeof Model>;\n\nconst x: Model = {\n  nickname: 'test',\n  somenumber: 'qwe',\n};\n"})}),"\n",(0,o.jsx)(e.p,{children:"Solution 2:\ncreate separate models that use same primitive-ish models, or not use same depending on business"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"const nickname = z.string().min(1)\nconst ddbPerson = z.object({ S: z.object({ nickname }) })\nconst Person = z.object({ nickname })\n"})})]})}function u(n={}){const{wrapper:e}={...(0,s.a)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},71670:(n,e,t)=>{t.d(e,{Z:()=>a,a:()=>r});var o=t(27378);const s={},i=o.createContext(s);function r(n){const e=o.useContext(i);return o.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:r(n.components),o.createElement(i.Provider,{value:e},n.children)}}}]);