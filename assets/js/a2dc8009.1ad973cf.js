"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[412],{8286:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>c,default:()=>l,frontMatter:()=>o,metadata:()=>i,toc:()=>d});var r=n(24246),s=n(71670);const o={},c=void 0,i={id:"my/public/software/architecture/validation",title:"validation",description:"https://zod.dev",source:"@site/docs/my/public/software/architecture/validation.md",sourceDirName:"my/public/software/architecture",slug:"/my/public/software/architecture/validation",permalink:"/note/docs/my/public/software/architecture/validation",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"mySidebar",previous:{title:"reCAPTCHA",permalink:"/note/docs/my/public/software/architecture/security/reCAPTCHA"},next:{title:"brew",permalink:"/note/docs/my/public/software/brew"}},a={},d=[{value:"https://zod.dev",id:"httpszoddev",level:2}];function u(e){const t={a:"a",blockquote:"blockquote",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"httpszoddev",children:(0,r.jsx)(t.a,{href:"https://zod.dev",children:"https://zod.dev"})}),"\n",(0,r.jsx)(t.p,{children:"2023-05\nimpression:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"helps further validate beyond TypeScript: string, number, etc"}),"\n",(0,r.jsxs)(t.li,{children:["but have some weird unintuitive strucuture due to limits (recursive, etc)\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"z.coerce"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsx)(t.p,{style:{},children:"\neach Zod schema internally tracks two types: an input and an output\n"}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["github has better doc\n",(0,r.jsx)(t.a,{href:"https://github.com/colinhacks/zod",children:"https://github.com/colinhacks/zod"}),"\ngf:/public/src/profession/javascript/zod"]}),"\n",(0,r.jsx)(t.p,{children:"trick"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"// works like zodSchema.parse (maybe it is better?), if needed to process more\nexport function parse<T extends z.ZodTypeAny>({\n  zodSchema,\n  zodSchemaName,\n  object,\n}: {\n  zodSchema: T;\n  zodSchemaName: string;\n  object: unknown;\n}): z.infer<T> {\n  const safeParseResult = zodSchema.safeParse(object);\n\n  if (!safeParseResult.success) {\n    // formatZodError is custom function\n    const errorMessage = formatZodError(safeParseResult.error, zodSchemaName);\n    logger.error('Error parsing object ', );\n    throw new ...\n  }\n\n  return safeParseResult.data;\n}\n"})})]})}function l(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},71670:(e,t,n)=>{n.d(t,{Z:()=>i,a:()=>c});var r=n(27378);const s={},o=r.createContext(s);function c(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);