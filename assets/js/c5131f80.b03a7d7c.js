"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[6363],{55785:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>c,toc:()=>l});var o=t(24246),s=t(71670);const i={},r=void 0,c={id:"my/public/software/JavaScript/zod",title:"zod",description:"vs. Typescript",source:"@site/docs/my/public/software/JavaScript/zod.md",sourceDirName:"my/public/software/JavaScript",slug:"/my/public/software/JavaScript/zod",permalink:"/note/docs/my/public/software/JavaScript/zod",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"mySidebar",previous:{title:"vite",permalink:"/note/docs/my/public/software/JavaScript/vite"},next:{title:"profile",permalink:"/note/docs/my/public/software/OS/Linux/Android/profile"}},a={},l=[{value:"vs. Typescript",id:"vs-typescript",level:3},{value:"other model (e.g. Typescript  prisma) to zod",id:"other-model-eg-typescript--prisma-to-zod",level:4},{value:"condition",id:"condition",level:3},{value:"operation on fields",id:"operation-on-fields",level:3},{value:"convert zod type automatically",id:"convert-zod-type-automatically",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",cite:"cite",code:"code",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h3,{id:"vs-typescript",children:"vs. Typescript"}),"\n",(0,o.jsx)(n.p,{children:"pros:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["has ",(0,o.jsx)(n.code,{children:"default()"})]}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"other-model-eg-typescript--prisma-to-zod",children:"other model (e.g. Typescript  prisma) to zod"}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.cite,{children:[" ",(0,o.jsx)(n.a,{href:"https://github.com/colinhacks/zod/issues/53",children:" 2023-12-31 Generating Zod schema from TS type definitions \xb7 Issue #53 \xb7 colinhacks/zod \xb7 GitHub "})," "]}),"\n",(0,o.jsx)(n.p,{style:{},children:"\nPrisma's trying to make the .prisma file the single declarative source\nof truth for your schema but don't provide any easy way to build\ncodegen tools on top of it\n"}),(0,o.jsx)(n.p,{children:"We initially redefined most of our TS types as zod schemas, then used\nz.infer to extract TS types. This works pretty well, but the extra\nlayers of inference seem to sometimes be causing compiler performance\nissues with complex types, and can also break some IDE features like\nGo to definition."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://github.com/vriad/tozod",children:"https://github.com/vriad/tozod"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"needs definition twice (ts, zod)"}),"\n",(0,o.jsx)(n.li,{children:"not mature  2023-12"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://github.com/fabien0102/ts-to-zod",children:"https://github.com/fabien0102/ts-to-zod"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"not verified"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"just use online tools"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://transform.tools/typescript-to-zod",children:"https://transform.tools/typescript-to-zod"})}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["see also ",(0,o.jsx)(n.code,{children:"packages/model/src/model/hardware/dishwasher.ts"})]}),"\n",(0,o.jsx)(n.p,{}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"condition",children:"condition"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.a,{href:"https://github.com/colinhacks/zod/issues/61",children:"Require 1 of 2 fields, good general discussion on conditional validation  zod \xb7 GitHub"}),"\n2023-08-31 no good neat solution"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"// https://stackoverflow.com/questions/73281501/at-least-one-minimum-one-field-in-zod-schema-validation\n\n// p2 need more testing\nconst atLeast1Defined = (obj: Record<string | number | symbol, unknown>) =>\n  Object.values(obj).some(v => v !== undefined);\n  \n"})}),"\n",(0,o.jsx)(n.h3,{id:"operation-on-fields",children:"operation on fields"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://github.com/colinhacks/zod/discussions/2050",children:"https://github.com/colinhacks/zod/discussions/2050"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"function makeOptionalPropsNullable<Schema extends z.AnyZodObject> ( schema: Schema ) {\n    const entries = Object.entries( schema.shape ) as\n        [ keyof Schema[ 'shape' ], z.ZodTypeAny ][]\n    const newProps = entries.reduce( ( acc, [ key, value ] ) => {\n        acc[ key ] = value instanceof z.ZodOptional\n            ? value.unwrap().nullable()\n            : value\n        return acc\n    }, {} as {\n        [ key in keyof Schema[ 'shape' ] ]: Schema[ 'shape' ][ key ] extends z.ZodOptional<infer T>\n        ? z.ZodNullable<T>\n        : Schema[ 'shape' ][ key ]\n    } )\n    return z.object( newProps )\n}\n\nconst Person = z.object( {\n    firstName: z.string(),\n    lastName: z.string(),\n    email: z.string().optional(),\n    address: z.string().nullable(),\n} )\n\nconst serverPerson = makeOptionalPropsNullable( Person )\ntype ServerPerson = z.infer<typeof serverPerson>\n// type ServerPerson = {\n//     firstName: string\n//     lastName: string\n//     email: string | null\n//     address: string | null\n// }\n"})}),"\n",(0,o.jsx)(n.h3,{id:"convert-zod-type-automatically",children:"convert zod type automatically"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"// I have this zod object\nz.object({nickname: z.string().min(1),\n    gender: z.union([\n      z.literal('male'),\n      z.literal('female'),\n    ])})\n    \n// to DynamoDB model (note the 'S')\n// I want this zod object (but not manually) somehow automatically\nz.object({nickname: z.object({ S: z.string().min(1)}),\n    gender: z.object({ S: z.union([\n      z.literal('male'),\n      z.literal('female'),\n    ])})})\n"})}),"\n",(0,o.jsx)(n.p,{children:"Solution 1 (reverse conversion)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"// don't do this, needs testing and deep understanding of zod\n\nconst nickname = z.string().min(1);\ntype nickname = z.infer<typeof nickname>;\n\nconst DdbModel = z.object({\n  S: z.object({\n    nickname,\n  }),\n  N: z.object({\n    somenumber: z.string(),\n  }),\n});\ntype DdbModel = z.infer<typeof DdbModel>;\n\nconst Model = DdbModel.transform((val) => {\n  if (val.S) {\n    return val.S;\n  }\n\n  return val.N;  // wrong, it's number\n});\ntype Model = z.infer<typeof Model>;\n\nconst x: Model = {\n  nickname: 'test',\n  somenumber: 'qwe',\n};\n"})}),"\n",(0,o.jsx)(n.p,{children:"Solution 2:\ncreate separate models that use same primitive-ish models, or not use same depending on business"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"const nickname = z.string().min(1)\nconst ddbPerson = z.object({ S: z.object({ nickname }) })\nconst Person = z.object({ nickname })\n"})})]})}function p(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},71670:(e,n,t)=>{t.d(n,{Z:()=>c,a:()=>r});var o=t(27378);const s={},i=o.createContext(s);function r(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);